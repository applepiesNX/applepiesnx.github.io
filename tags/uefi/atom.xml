<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>applepiesNX&#x27;s Blog - UEFI</title>
	<link href="https://applepiesnx.github.io/tags/uefi/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://applepiesnx.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-02-18T00:00:00+00:00</updated>
	<id>https://applepiesnx.github.io/tags/uefi/atom.xml</id>
	<entry xml:lang="en">
		<title>Rust OS - Part 1</title>
		<published>2022-02-18T00:00:00+00:00</published>
		<updated>2022-02-18T00:00:00+00:00</updated>
		<link href="https://applepiesnx.github.io/blog/os-part-1/" type="text/html"/>
		<id>https://applepiesnx.github.io/blog/os-part-1/</id>
		<content type="html">&lt;p&gt;Welcome to part 1 of this blog series that will focus on creating a operating system kernel purely in rust.
This project was started as a means to deepen my knowledge of both Rust and operating system internals.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;Before we begin creating our kernel we need to make a few design decisions like what architecture
we are targeting and how our kernel will be booted. The present guide will focus on creating a kernel
targeting the x86_64 architecture. &lt;br &#x2F;&gt;
As for booting there are many paths we can take such as using BIOS, UEFI or
making our kernel multiboot2 compliant so that we can use any multiboot2 bootloader. Theres an argument
to be made for each of them but to keep things short we will be using a systems UEFI firmware to boot
our kernel. Therefore, the first step in creating our kernel will be to a write a UEFI bootloader in Rust.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;uefi-bootloader&quot;&gt;UEFI Bootloader&lt;&#x2F;h1&gt;
&lt;p&gt;The first step would be to simply use cargo to create a new rust project.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo new bootloader-rust
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;building-the-bootloader&quot;&gt;Building the Bootloader&lt;&#x2F;h2&gt;
&lt;p&gt;In order to compile this project so that it can be executed by the  UEFI firmware, we need to tell cargo that we are building this project for a x86_64 uefi system that has no underlying operating system. By default cargo will compile the project to be run on the operating system and architecture that it is being built on. We can overwrite this behaviour by passing the &lt;code&gt;--target=TARGET&lt;&#x2F;code&gt; flag to cargo to specify which target we want to build for. Fortunately for us Rust has an inbuilt target that we can use to build our project to be run directly on the UEFI firmware. Rust also supports the creation of our own custom targets, however we will get to that in a later part when we are creating our kernel. For now, lets use the in-built &lt;code&gt; x86_64-unknown-uefi&lt;&#x2F;code&gt; target to compile our project. We will also need to use the nightly compiler as we need to use a few unstable features. If the nightly compiler is not install it can be installed with the following command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;rustup install nightly
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now with all that done, in order to build our bootloader we will run the following command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo +nightly build --target=x86_64-unknown-uefi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we run this command we get the following error:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;error[E0463]: can&amp;#39;t find crate for `std`
&lt;&#x2F;span&gt;&lt;span&gt;  |
&lt;&#x2F;span&gt;&lt;span&gt;  = note: the `x86_64-unknown-uefi` target may not be installed
&lt;&#x2F;span&gt;&lt;span&gt;  = help: consider downloading the target with `rustup target add x86_64-unknown-uefi`
&lt;&#x2F;span&gt;&lt;span&gt;  = help: consider building the standard library from source with `cargo build -Zbuild-std`
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is because the std crate depends on the underlying operating system to provide various features such as memory allocation. But we do not have an underlying operating system to provide these services therefore we need to tell the compiler that we do not intend to use the std crate. We do this by adding &lt;code&gt;#![no_std]&lt;&#x2F;code&gt; to the beginning of our &lt;code&gt;main.rs&lt;&#x2F;code&gt; file. &lt;&#x2F;p&gt;
&lt;p&gt;Now if we try to build it again we get a different error. Its a very similar error however, this time its complaining about the lack of the &lt;code&gt;core&lt;&#x2F;code&gt; and &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt; crates. Unlike the &lt;code&gt;std&lt;&#x2F;code&gt; crate , we dont have an option of not using these crates as they are entire foundation the Rust language is built on. The reason these crates cant be found is becuase Rust does not provide precompiled binaries for the UEFI target. 
However, the nightly version of Rust does give us the option of compiling these crates on our own, and thats exactly what we&#x27;ll be doing.&lt;&#x2F;p&gt;
&lt;p&gt;In order to compile these crates ourselves, we must first acquire the source for libstd. The following command can be used to download the source:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;rustup component add rust-src
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;once thats done we need to tell Cargo to use the unstable &lt;code&gt;build-std&lt;&#x2F;code&gt; feature to build the &lt;code&gt;core&lt;&#x2F;code&gt; and &lt;code&gt;compiler_builtins&lt;&#x2F;code&gt; crates. we do that by using the &lt;code&gt;-Z build-std&lt;&#x2F;code&gt; flag. Passing this flag will cause Cargo to implicitly build &lt;code&gt;core, std, alloc, and proc_macro&lt;&#x2F;code&gt; crates , however we will be specifying the exact crates we want to build by using the following syntax : &lt;code&gt;-Z build-std=&amp;lt;crates to build&amp;gt;&lt;&#x2F;code&gt;. With all that done our new build command looks like the following:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;cargo +nightly build -Z build-std=core,compiler_builtins --target=x86_64-unknown-uefi
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we get two more new errors. The first is about the &lt;code&gt;println!&lt;&#x2F;code&gt; macro. This is to be expected as the  &lt;code&gt;println!&lt;&#x2F;code&gt; macro is provided by the &lt;code&gt;std&lt;&#x2F;code&gt; crate that we do not have access to. We can simply remove the macro from our code and the error should disappear. &lt;&#x2F;p&gt;
&lt;p&gt;The second error we have is complaining about the lack of a panic_handler function. Looking at the Rust documentation, it says that this funciton defines what the program will do when it panics. This fucntionality is normally provided by the &lt;code&gt;std&lt;&#x2F;code&gt; crate. This means we will have to define our own panic handler if we want to compile our program.&lt;&#x2F;p&gt;
&lt;p&gt;The panic handler function must have the following signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;&#x2F;code&gt;, and it needs to be marked with the &lt;code&gt;#[panic_handler]&lt;&#x2F;code&gt; attribute. Sounds easy enough so lets add it to our &lt;code&gt;main.rs&lt;&#x2F;code&gt; file. First we need to import the &lt;code&gt;PanicInfo&lt;&#x2F;code&gt; struct which is defined in the &lt;code&gt;core&lt;&#x2F;code&gt; crate. adding &lt;code&gt; use core::panic::PanicInfo;&lt;&#x2F;code&gt; to our file will take care of that. Next, we need to define a function with the above signature.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;panic_handler&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;panic&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_info&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;PanicInfo) -&amp;gt;!{
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For the time being we will simply loop if our program panics. We will later expand the functionality of this as we become able to interact with the UEFI firmware.
With all of the above code added to our &lt;code&gt;main.rs&lt;&#x2F;code&gt; file, it  should look like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_std&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;panic_handler&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;panic&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_info&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;PanicInfo) -&amp;gt;!{
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have a new error. The compiler is complaining about the lack of the &lt;code&gt;start&lt;&#x2F;code&gt; &lt;code&gt;lang_item&lt;&#x2F;code&gt;. The start lang item is what defines the entry point of our program. When a program is executed, the first function that is run is not the main funciton but an entry point function that serves a few purposes, like setting up the stack for the program. The UEFI specification defines a function called &lt;code&gt;EFI_IMAGE_ENTRY_POINT&lt;&#x2F;code&gt; , this function is what the UEFI firmware expects to handover execution to. For UEFI application written in Rust the linker looks for a function named &lt;code&gt;efi_main&lt;&#x2F;code&gt; as the entry point. So lets add one. First we need to add &lt;code&gt;#![no_main]&lt;&#x2F;code&gt; to the top of our &lt;code&gt;main.rs&lt;&#x2F;code&gt; file to notify the compiler that our program will not have a standard main function. Next we will remove our existing main function and replace it with a function named efi_main. &lt;&#x2F;p&gt;
&lt;p&gt;However, simply doing so will not make our UEFI app compile. There are two issues here. Firstly, the name of our function gets mangled by the compiler to a less human readable name that contains information that makes compilation easier. This is a problem as the linker will be looking for a function with the name &lt;code&gt;efi_main&lt;&#x2F;code&gt;. The second problem is the calling convention of the function. The calling convention of a function defines many things including how parameters are passed to it , whether they are stored on the stack or passed through registers etc. Its very important that our &lt;code&gt;efi_main&lt;&#x2F;code&gt; function uses the calling convention the UEFI firmware expects us to.&lt;&#x2F;p&gt;
&lt;p&gt;The first issue can be solved by adding the  &lt;code&gt;#[no_mangle]&lt;&#x2F;code&gt; attribute to our &lt;code&gt;efi_main&lt;&#x2F;code&gt; function. This tells the compiler to not mangle its name.
For the second issue, Rust allows us to specify which calling convention we want to use with our functions through the following syntax: &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extern &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;[calling convention]&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;my_function&lt;&#x2F;span&gt;&lt;span&gt;()-&amp;gt;!{}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Fortunately for us Rust supports the calling convention used by the UEFI firmware. In order to use it we need to first add &lt;code&gt;#![feature(abi_efiapi)]&lt;&#x2F;code&gt; to our &lt;code&gt;main.rs&lt;&#x2F;code&gt; file. Next we need to edit our definition of the &lt;code&gt;efi_main&lt;&#x2F;code&gt; function and add &lt;code&gt;pub extern &amp;quot;efiapi&amp;quot; fn efi_main&lt;&#x2F;code&gt; to it. With all these changes made our main.rs file should now look like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_std&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_main&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;feature&lt;&#x2F;span&gt;&lt;span&gt;(abi_efiapi)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;core::panic::PanicInfo;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub extern &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;efiapi&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;efi_main&lt;&#x2F;span&gt;&lt;span&gt;() {	
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;panic_handler&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;panic&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_info&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;PanicInfo) -&amp;gt;!{
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And Finally attempting to compile it results in no errors! 😃&lt;&#x2F;p&gt;
&lt;p&gt;That all for part one. We have managed to create a basic UEFI app that we can build upon and turn into our bootloader. In the next part I will use the UEFI firmware&#x27;s built in functions to print to the screen. &lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
